---
title: Spock random order of tests - how to?
date: 2019-04-06 10:52:11
updated: 2019-04-06 10:52:11
tags:
    - groovy
    - spock
    - unit-test
    - random
    - junit
categories:
    - Groovy Cookbook
cover: /images/spock-random-tests-bg.jpg
og_image: /images/og/spock-random-tests.jpg
eyeCatchImage: /images/og/spock-random-tests.jpg
---

http://spockframework.org/[Spock Framework] executes test methods _(features)_ in a single class _(specification)_ in the declaration order.
There is nothing wrong in this default behavior - we should write tests with their isolation in mind.
However, in some cases, we would like to randomize test methods execution.
Today we are going to learn how to do it.

++++
<!-- more -->
++++

== Introduction

Let's start with a reasonably simple specification that prints a number to the console.

.src/test/groovy/com/github/wololock/RandomSpockSpec.groovy
[source,groovy]
----
package com.github.wololock

import spock.lang.Specification

class RandomSpockSpec extends Specification {

    def "test 1"() {
        when:
        def number = 1

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 2"() {
        when:
        def number = 2

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 3"() {
        when:
        def number = 3

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 4"() {
        when:
        def number = 4

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 5"() {
        when:
        def number = 5

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }
}
----

When we execute this specification, we get all numbers printed in the ascending order.

[.text-center]
--
[.img-responsive.img-thumbnail]
[link=/images/spock-random-tests-01.jpg]
image::/images/spock-random-tests-01.jpg[]
--

NOTE: You can find the source code of this example in the https://github.com/wololock/spock-random-order-demo[following repository].

== Forcing random order

Now let's try to randomize the execution order. One way to do it is to use Spock's extensions - an http://spockframework.org/spock/docs/1.1/extensions.html#_annotation_driven_local_extensions[annotation-driven local extensions] in this case.
Let's create a new annotation called `@RandomizedOrder` with the following content.

.src/test/groovy/com/github/wololock/RandomizedOrder.groovy
[source,groovy]
----
package com.github.wololock

import org.spockframework.runtime.extension.ExtensionAnnotation

import java.lang.annotation.ElementType
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Target

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ExtensionAnnotation(RandomizedOrderExtension)
@interface RandomizedOrder {}
----

After creating annotation interface, we can create the extension class. This class implements `visitSpecAnnotation`
interceptor method that gets executed right before specification executes any feature.

.src/test/groovy/com/github/wololock/RandomizedOrderExtension.groovy
[source,groovy]
----
package com.github.wololock

import org.spockframework.runtime.extension.AbstractAnnotationDrivenExtension
import org.spockframework.runtime.model.SpecInfo

final class RandomizedOrderExtension extends AbstractAnnotationDrivenExtension<RandomizedOrder> {

    @Override
    void visitSpecAnnotation(RandomizedOrder annotation, SpecInfo spec) {
        final List<Integer> order = (0..(spec.features.size())) as ArrayList //<1>

        Collections.shuffle(order) //<2>

        spec.features.each { feature ->
            feature.executionOrder = order.pop() //<3>
        }
    }
}
----
<1> A list of all possible orders (0..n).
<2> Here we shuffle the list to get its random permutation.
<3> For each feature method iterated in the declaration order we assign a unique order popped from the shuffled list.

This way we override the default execution order of each feature. By default, every feature uses execution order
set based on the declaration order. _(The first method gets `executionOrder == 0`, the second one gets `executionOrder == 1` and so on.)_

The last thing we need to do is to add `@RandomizedOrder` annotation to our specification class.

.`@RandomizedOrder` annotationed specification class
[source,groovy]
----
package com.github.wololock

import spock.lang.Specification

@RandomizedOrder
class RandomSpockSpec extends Specification {

    def "test 1"() {
        when:
        def number = 1

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 2"() {
        when:
        def number = 2

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 3"() {
        when:
        def number = 3

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 4"() {
        when:
        def number = 4

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }

    def "test 5"() {
        when:
        def number = 5

        then:
        println "[${new Date().format("HH:mm:ss.SSS")}] number ${number}"
    }
}
----

We are ready to run the test now. Let's see if the execution order has changed.

[.text-center]
--
[.img-responsive.img-thumbnail]
[link=/images/spock-random-tests-02.jpg]
image::/images/spock-random-tests-02.jpg[]
--

*It worked!* We can see that in the above example the execution order was: Test 4, Test 3, Test 5, Test&nbsp;1, and Test 2.
And what's even more important - the solution is simple and clean.